<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">

<!--     -->
<head>
<!-- GenHTML revision 23224-->
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>How to Create and Use a Custom AI Manifest - OpenSolaris 2010.03 Automated Installer Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2010-03-01">
<meta name="collection" content="reference">
<link rel="stylesheet" type="text/css" href="css/elements.css">
<link rel="stylesheet" type="text/css" href="css/opensol.css">
</head>

<body>


<div class="Masthead">
   <div class="MastheadLogo">
      <a href="http://www.opensolaris.com"><img border="0" src="graphics/opensolaris_logo_trans.png"></img></a>
   </div>
   <div class="Title">OpenSolaris 2010.03 Automated Installer Guide</div>
</div>
<div class="headerbar"></div>


<table class="Layout" border="0" cellspacing="0" width="100%">
<tbody>

   <tr valign="top" class="PageControls">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="manifest1.html">Previous</a>
             </td>
             <td align="right">
                 <a href="customsc.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
   
   <tr valign="top">
      <td class="Navigation" width="200px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="index.html">1.&nbsp;&nbsp;What's New For Automated Installations</a></p>
<p class="toc level1 tocsp"><a href="intro.html">2.&nbsp;&nbsp;Introduction to the Automated Installer</a></p>
<p class="toc level1 tocsp"><a href="tasks.html">3.&nbsp;&nbsp;Automated Installer Task Map</a></p>
<p class="toc level1 tocsp"><a href="bootable.html">4.&nbsp;&nbsp;Automated Installations Using Media</a></p>
<p class="toc level1 tocsp"><a href="setup.html">5.&nbsp;&nbsp;Automated Installer Setup Instructions</a></p>
<p class="toc level1 tocsp"><a href="administer.html">6.&nbsp;&nbsp;How to Administer an Automated Install Server</a></p>
<p class="toc level1 tocsp"><a href="client.html">7.&nbsp;&nbsp;How to Administer a Custom Install Client</a></p>
<p class="toc level1 tocsp"><a href="manifest.html">8.&nbsp;&nbsp;How to Administer the Manifest Files for an Install Service</a></p>
<p class="toc level2"><a href="manifest1.html">Types of Manifests</a></p>
<div id="scrolltoc" class="onpage">
<p class="toc level2"><a href="">How to Create and Use a Custom AI Manifest</a></p>
</div>
<p class="toc level2"><a href="customsc.html">How to Create Custom SC Manifest Files</a></p>
<p class="toc level2"><a href="criteria.html">How to Create and Use a Criteria Manifest</a></p>
<p class="toc level2"><a href="associate.html">How to Assign Manifests to a Client</a></p>
<p class="toc level1 tocsp"><a href="clients.html">9.&nbsp;&nbsp;How to Manage Client Installations</a></p>
<p class="toc level1 tocsp"><a href="trouble.html">10.&nbsp;&nbsp;Troubleshooting and FAQs for the Automated Installer</a></p>
<p class="toc level1 tocsp"><a href="appendix.html">11.&nbsp;&nbsp;Appendix</a></p>
</td>
      <td class="ContentPane" width="705px">

	 <div class="MainContent">      	 
             

<a name="customai"></a><h3>How to Create and Use a Custom AI Manifest</h3>
<p>When you create an install service by using the <tt>installadm create-service</tt> command, an
AI manifest is automatically copied to the install service. This manifest has default
settings that are sufficient for client installations. However, you can make a custom
manifest and change the specifications in that manifest to create specific installations for
specific clients.See the following sections.</p>
<ul><li><p><a href="#aifields">Reviewing the AI Manifest Tags</a></p></li>
<li><p><a href="#changeai">Replacing Default AI Manifest with a Custom Manifest</a></p></li>
<li><p><a href="#aioptions">Modifying AI Manifest Contents</a></p></li>
<li><p><a href="#allfields">Example: A Complete AI Manifest</a></p></li></ul>


<a name="aifields"></a><h4>Reviewing the AI Manifest Tags</h4>
<p>The AI manifest is an XML file that contains a series of
tags and tag values. Each tag and value is enclosed inside XML tags.</p><p>The XML tags all contain a start tag, such as <tt>&lt;name&gt;</tt>, and
an ending tag, such as <tt>&lt;/name&gt;</tt>. Within each tag, a tag name is
given, then that tag's value is given. A tag is a parameter that
specifies a piece of information about the manifest itself or about the manifest's
installation specifications. Each tag has a value that can be edited to modify
the manifest information or to modify the installation specifications in the manifest.</p><p>For example, see this line in the manifest:</p><pre>&lt;ai_manifest name="default&quot;&gt;</pre><p>This <tt>&lt;ai_manifest name></tt> tag assigns a name to the manifest. The value that is
given for this tag is &ldquo;default.&rdquo; You can change this value.</p>
<hr><p><b>Note - </b>The <tt>&lt;ai_manifest name></tt> tag with the value, &ldquo;default,&rdquo; indicates that the manifest is the
default manifest. There can be only one default manifest per install service. You
can modify or replace the default manifest.</p>
<hr>
<p>Note the following information about other tags in the AI manifest:</p>
<ul><li><p>You can use the <tt>&lt;ai_target_device></tt> tag to specify a particular target disk on which to install the OpenSolaris OS. See <a href="#iediskrepo">Defining a Target for the Installation</a>. If you do not specify a target disk, the automated installer chooses a default target for installing the OpenSolaris OS.</p>
<ol><li><p>The installer gets the recommended size for installing the OpenSolaris OS from the AI libraries. Currently, the recommended size is 13 GB.</p></li>
<li><p>The installer searches for available disks on the client. To determine the default target, the automated installer looks for an available disk with at least recommended size.</p></li>
<li><p>When the first disk is found, the installer checks the size of that disk.</p>
<ul><li><p>If the size is greater than or equal to the recommended size, the installer selects the disk and returns to the installation procedure.</p></li>
<li><p>If the size is less than the recommended size, the installer goes to the next disk to check the size.</p></li></ul>
</li>
<li><p>If there is no match, the automated installation fails.</p></li></ol>
</li>
<li><p>The tag, <tt>&lt;ai_pkg_repo_default_publisher></tt>, defines the IPS repository from which the installation will be performed. You need to provide the URL of the IPS repository and the publisher. In the default AI manifest, the IPS repository is set to <a href="http://pkg.opensolaris.org/release/">http://pkg.opensolaris.org/release/</a>, and the publisher is defined as <tt>opensolaris.org</tt>.</p></li>
<li><p>In the tag, <tt>&lt;ai_install_packages></tt>, the default manifest instructs the automated installer to install the following packages to the client:</p>
<ul><li><p><tt>entire</tt></p></li>
<li><p><tt>SUNWcsd</tt></p></li>
<li><p><tt>SUNWcs</tt></p></li>
<li><p><tt>babel_install</tt></p></li></ul>

<hr><p><b>Note - </b>Due to dependency issues, <tt>entire</tt> must be listed first in the package list, followed by <tt>SUNWcsd</tt>, and then <tt>SUNWcs</tt>. Any additional packages must be listed after <tt>SUNWcs</tt>.</p>
<hr>
</li>
<li><p>The tag, <tt>&lt;ai_uninstall_packages></tt>, lists packages, <tt>babel_install</tt> and <tt>slim_install</tt>, that will be uninstalled from the client.</p>
<hr><p><b>Note - </b>Why does the default manifest first install the <tt>babel_install</tt> package, then uninstall it?</p><p><tt>babel_install</tt> is a cluster consisting of a set of packages. When the <tt>babel_install</tt> cluster is installed, all the packages in the cluster are installed. However, you cannot uninstall packages that belong to a cluster. By uninstalling the cluster definition, the individual packages can be deleted later. <tt>babel_install</tt> is used for convenience to install all the required packages, but the cluster definition is not needed after installation of packages are completed. The default manifest removes the cluster definition, so that further customization of the packages can be done.</p><p><tt>slim_install</tt> is another cluster. And, <tt>slim_install</tt> is part of <tt>babel_install</tt> which is installed by the default manifest. The default manifest uninstalls <tt>slim_install</tt>, in order to permit customization.</p>
<hr>
</li>
<li><p>The tag, <tt>&lt;ai_auto_reboot></tt>, can be used to request automatic reboot after successful installation. The default value is <tt>false</tt>, meaning that the client does not automatically reboot after successful installation. If this value is changed to <tt>true</tt>, the client automatically reboots after successful installation.</p></li>
<li><p>The second part of the default AI manifest is an embedded SC manifest, beginning at the line:</p><pre>&lt;sc_embedded_manifest name = &quot;AI&quot;&gt;</pre><p>For instructions about how to modify the SC manifest, see <a href="customsc.html">How to Create Custom SC Manifest Files</a>.</p></li></ul>

<hr><p><b>Note - </b>For a summary of the AI manifest contents and possible values, see <a href="aimanifest.html">AI Manifest Contents</a>.</p>
<hr>


<a name="changeai"></a><h4>Replacing Default AI Manifest with a Custom Manifest</h4>
<p>You can replace the default AI manifest for an install service with a
custom manifest that you created and revised to suit specific client specifications. Use
the following procedure to create a custom manifest and assign it to
an install service.</p>
<ol><li><p>Copy the automated installer's default manifest from the target image path that is associated with the install service you plan to use.</p><p>The target image path for an install service can be determined with the following command, where <i>srvname</i> is the name of the install service.</p><pre>#  # installadm list -n <i>srvname</i></pre><p>For example, see the following command and output:</p><pre># installadm list -n svc1
   Service Name Status       Arch    Port  Image Path
   ------------ ------       ----    ----  ----------
   svc1         on           sparc   45603 /export/aiserver/svc1</pre><p>In the above example, the install service, <tt>svc1</tt>, has an image path of <tt>/export/aiserver/svc1</tt>. The default manifest, <tt>default.xml</tt>, located in this image path is at:</p><pre><tt>/export/aiserver/svc1/auto_install/default.xml</tt></pre>
<hr><p><b>Note - </b>For services created with images that date back prior to the OpenSolaris 2009.06 release, you can copy the <tt>default.xml</tt> manifest located on the install server at <tt>/usr/share/auto_install/default.xml</tt>.</p>
<hr>
</li>
<li><p>Keep the <tt>&lt;ai_manifest name></tt> tag in your manifest copy set to the value of <tt>default</tt>.</p></li>
<li><p>Revise the <tt>&lt;ai_embedded_manifest></tt> and <tt>&lt;sc_embedded_manifest></tt> sections of your copy as needed.</p></li>
<li><p>Use the <tt>installadm add</tt> command to replace the default manifest for an existing install service with your copy as follows:</p><pre># <tt>/usr/sbin/installadm add <tt>-m</tt> <i>manifest_file</i> <tt>-n</tt> <i>svc_name</i></tt></pre><p>Where <tt>manifest_file</tt> is the name of the manifest copy that you created and modified, and where <tt>svc_name</tt> is the name of the install service.</p><p>The <tt>installadm add</tt> command validates your manifest before replacing the default manifest.</p></li></ol>

<hr><p><b>Note - </b>The build number or release of the OpenSolaris operating system that you specify
in the AI manifest must match the build number or release of the
AI ISO image that you specify in the <tt>installadm create-service</tt> command with the
<tt>-s</tt> option. For further information, see <a href="#version">Specifying Packages to Install a Specific Version of OpenSolaris</a>.</p>
<hr>


<a name="aioptions"></a><h4>Modifying AI Manifest Contents</h4>
<p>Once you've created what will be your custom AI manifest, you can
edit the tags in this custom file. The following examples show options for
modifying the contents of your custom AI manifest.</p>
<hr><p><b>Note - </b>The examples in this section are partial excerpts from AI manifest files, showing
only the tags being discussed in that example. Only the last example shows
a complete AI manifest.</p>
<hr>

<ul><li><p><a href="#iediskrepo">Defining a Target for the Installation</a></p></li>
<li><p><a href="#modpart">Modifying the Partitions and Slices on the Install Client</a></p></li>
<li><p><a href="#iereboot">Specifying an Automatic Reboot After Installation</a></p></li>
<li><p><a href="#repo">Specifying an IPS Repository</a></p></li>
<li><p><a href="#iepkg">Specifying Packages to be Installed</a></p></li>
<li><p><a href="#allfields">Example: A Complete AI Manifest</a></p></li></ul>

<hr><p><b>Note - </b>For further information about specific AI manifest tags and valid values for these
tags, see <a href="aimanifest.html">AI Manifest Contents</a>.</p>
<hr>


<a name="iediskrepo"></a><h5>Defining a Target for the Installation</h5>
<p>You can specify a target location on a client for installing the
OpenSolaris OS as described below.</p>
<hr><p><b>Note - </b>If you do not specify a target disk, the automated installer chooses a
default target for installing the OpenSolaris OS. See <a href="faq.html#targetdisk">14. How is the Default Target Disk Selected?</a>.</p>
<hr>
<p>There a variety of options for specifying a target installation location. One option
is to enter an MPXIO name or a logical device name in
the tag, <tt>&lt;ai_target_device></tt>, as shown in these examples.</p><p>Using a logical device name:</p><pre>...
&lt;ai_target_device>
     &lt;target_device_name>c0t0d0&lt;/target_device_name>
&lt;/ai_target_device>
...</pre><p>Using an MPXIO name:</p><pre>...
&lt;ai_target_device>
     &lt;target_device_name>c0t0000002037CD9F72d0&lt;/target_device_name>
&lt;/ai_target_device>
...</pre><p>Or, you can specify a VTOC slice as the installation target. See
<a href="#ievtoc">Using a VTOC Slice as the Installation Target</a>.</p><p>Alternately, <b>starting with the OpenSolaris 2010.03 release</b>, you can use the following new options to specify an
installation target.</p>
<ul><li><p><a href="#bootdisk">Using the Boot Disk as the Installation Target</a></p></li>
<li><p><a href="#devid">Using the Device ID to Specify an Installation Target</a></p></li>
<li><p><a href="#phydevice">Using Physical Device Path to Specify an Installation Target</a></p></li>
<li><p><a href="#volname">Using Volume Name to Specify an Installation Target</a></p></li>
<li><p><a href="#iscsi">Using an iSCSI Target for Installations</a></p></li></ul>
<p>You can specify multiple criteria for determining the installation target, but there are
limitations. See <a href="#multarget">Using Multiple Criteria to Specify an Installation Target</a>.</p>

<a name="bootdisk"></a><h5>Using the Boot Disk as the Installation Target</h5>
<p>The <tt>&lt;ai_target_device></tt> tag now accepts <tt>boot_disk</tt> as a keyword. This keyword can
be used to specify the current boot disk as the installation target as
follows:</p><pre>...
&lt;ai_target_device>
    &lt;target_device_name>
        boot_disk
    &lt;/target_device_name>
&lt;/ai_target_device>
...</pre><p>Note the following limitations to the <tt>boot_disk</tt> keyword:</p>
<ul><li><p>The <tt>boot_disk</tt> keyword does not work in XEN/PV, because information about the boot disk is not available in that environment.</p></li>
<li><p>Some x86 BIOS's do not report the boot disk correctly. See <a href="http://bugs.opensolaris.org/bugdatabase/view_bug_.do?bug_id=6831009">http://bugs.opensolaris.org/bugdatabase/view_bug_.do?bug_id=6831009</a>.</p></li>
<li><p>For SPARC clients, if the <tt>diag-switch?</tt> OBP property is set to <tt>true</tt>, information about the boot disk is not available. If you would like to utilize boot disk keyword on SPARC platforms, check that the <tt>diag-switch?</tt> is set to false.</p></li></ul>


<a name="devid"></a><h5>Using the Device ID to Specify an Installation Target</h5>
<p>You can use the new <tt>&lt;target_device_select_id></tt> tag to select a target disk by
its device ID.</p><p>You can get the device ID by using the <tt>iostat</tt> command as in
this example:</p><pre>$ iostat -iEn

c7d0             Soft Errors: 0 Hard Errors: 0 Transport Errors: 0
Model: ST31000340NS    Revision:  Device Id:
id1,cmdk@AST31000340NS=9QJ2LNYY
...</pre><p>Include the <tt>&lt;target_device_select_id></tt> tag as shown in the following example:</p><pre>...
&lt;ai_target_device>
    &lt;target_device_select_id>
        id1,cmdk@AST31000340NS=9QJ2LNYY
    &lt;/target_device_select_id>
&lt;/ai_target_device>
...</pre><p>Note the following limitations for the <tt>&lt;target_device_select_id></tt> tag:</p>
<ul><li><p>The tag does not work in XEN/PV, because the Device ID is not available for virtual drives.</p></li>
<li><p>The <tt>iostat</tt> command does not report the Device ID on LDOM guests. However, that information is available, and can be obtained by using the Target Discovery test driver which is present in the automated installation application. Use the test driver as demonstrated in this example.</p><pre># /opt/install-test/bin/tdmgtst -dv | grep ddm_disk_dev_id
ddm_disk_dev_id=id1,vdc@f8498536e4a8ad037000bcb400001</pre></li></ul>


<a name="phydevice"></a><h5>Using Physical Device Path to Specify an Installation Target</h5>
<p>You can use the new tag, <tt>&lt;target_device_select_device_path></tt>, to select a target disk
by specifying the physical path in the <tt>/devices</tt> directory.</p><p>One way to find the physical path is to look at the
related <tt>c#t#d#s#</tt> symbolic link, as in the following example.</p><pre>$ ls -l /dev/dsk/c7d0s0
lrwxrwxrwx 1 root root 51 2009-04-03 00:20 /dev/dsk/c7d0s0 ->
../../devices/pci@0,0/pci-ide@1f,2/ide@0/cmdk@0,0:a</pre><p>Include the <tt>&lt;target_device_select_device_path></tt> tag as shown in the following example:</p><pre>...
&lt;ai_target_device>
    &lt;target_device_select_device_path>
        /pci@0,0/pci-ide@1f,2/ide@0/cmdk@0,0
    &lt;/target_device_select_device_path>
&lt;/ai_target_device>
...</pre>

<a name="volname"></a><h5>Using Volume Name to Specify an Installation Target</h5>
<p>You can use the new tag, <tt>&lt;target_device_select_volume_name></tt>, to select a target disk
by specifying a volume name that was created using the <tt>format</tt> command.</p><p>The following example shows how to create a volume name.</p><pre>format -d c0d0 > /dev/null 2>/dev/null - &lt;&lt;EOF
volname
"ai-disk"
y
quit
EOF</pre><p>Include the <tt>&lt;target_device_select_volume_name></tt> tag as shown in the following example:</p><pre>...
&lt;ai_target_device>
    &lt;target_device_select_volume_name>
        ai-disk
    &lt;/target_device_select_volume_name>
&lt;/ai_target_device>
...</pre>

<a name="iscsi"></a><h5>Using an iSCSI Target for Installations</h5>
<p>With iSCSI technology, you can install to a disk drive hosted by
another computer on the same TCP/IP network. Starting with the OpenSolaris 2010.03 release, you
can specify an iSCSI target for automated installations, as shown in this example.</p><pre>...
&lt;ai_target_device>
    &lt;target_device_iscsi_target_name>iqn.1986-03.com.sun:02: \
c9e1533d-2d61-c198-b4ea-a9e3c40a49dd&lt;/target_device_iscsi_target_name>
    &lt;target_device_iscsi_target_ip>10.0.0.1&lt;/target_device_iscsi_target_ip>
    &lt;target_device_iscsi_target_port>3260&lt;/target_device_iscsi_target_port>
    &lt;target_device_iscsi_target_lun>0&lt;/target_device_iscsi_target_lun>
&lt;/ai_target_device>
...</pre><p>The following table describes each iSCSI tag.</p><a name="iscsitbl"></a><h6>Table&nbsp;8-1 iSCSI Tags</h6><table><col width="25%"><col width="25%"><col width="25%"><col width="25%"><tr><th align="left" valign="top" scope="column"><p>Tag Name</p></th>
<th align="left" valign="top" scope="column"><p>Description</p></th>
<th align="left" valign="top" scope="column"><p>Required?</p></th>
<th align="left" valign="top" scope="column"><p>Valid Values</p></th>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>&lt;target_device</tt></p><p><tt>_iscsi_target_name></tt></p></td>
<td align="left" valign="top" scope="row"><p>Target name, such as
IQN, EUI, or NAA</p></td>
<td align="left" valign="top" scope="row"><p>Required</p></td>
<td align="left" valign="top" scope="row"><p>A-Z, a-z, 0&ndash;9, periods, hyphens, colons</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>&lt;target_device</tt></p><p><tt>_iscsi_target_ip></tt></p></td>
<td align="left" valign="top" scope="row"><p>IP address of the
target</p></td>
<td align="left" valign="top" scope="row"><p>Required</p></td>
<td align="left" valign="top" scope="row"><p>Valid IP address</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>&lt;target_device</tt></p><p><tt>_iscsi_target_port></tt></p></td>
<td align="left" valign="top" scope="row"><p>IP port for the target</p></td>
<td align="left" valign="top" scope="row"><p>Optional, defaults to 3260</p></td>
<td align="left" valign="top" scope="row"><p>Integer between 0&ndash;65535</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>&lt;target_device</tt></p><p><tt>_iscsi_target_lun></tt></p></td>
<td align="left" valign="top" scope="row"><p>Logical
unit number specifies a SCSI device on the target. This may be needed
to distinguish between multiple boot disks on the same target.</p></td>
<td align="left" valign="top" scope="row"><p>Optional, defaults to
zero (0)</p></td>
<td align="left" valign="top" scope="row"><p>Decimal integers 0&ndash;16383 or 1&ndash;4 single hexadecimal digits separated by hyphens between
0 and 1&ndash;f-f-f</p></td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><tt>&lt;target_device</tt></p><p><tt>_iscsi_parameter_source></tt></p></td>
<td align="left" valign="top" scope="row"><p>Indicates where the iSCSI boot parameters will be sought.</p></td>
<td align="left" valign="top" scope="row"><p>Optional, defaults
to the AI manifest</p></td>
<td align="left" valign="top" scope="row"><p>&ldquo;manifest&rdquo;, &ldquo;DHCP&rdquo;</p></td>
</tr>
</table><p>To specify an iSCSI target in the AI manifest, you must first
create an iSCSI boot target by using the <tt>iscsitadm</tt> command.  Then, use the
<tt>iscsitadm</tt> information to complete the above iSCSI manifest tags. See (link to public
wiki URL).</p>
<hr><p><b>Note - </b>To use an iSCSI target, the packages, <tt>SUNWiscsi</tt> and <tt>SUNWiscsidm</tt>, must be
included in the <tt>&lt;ai_install_packages></tt> tag in the AI manifest as follows:</p><pre>...
&lt;ai_install_packages>
  ...
  &lt;pkg name="SUNWiscsi"/>
  &lt;pkg name="SUNWiscsidm"/>
&lt;/ai_install_packages>
...</pre><p>These packages are in the default AI manifest. Check to be sure
you have included them in any custom manifests.</p>
<hr>


<a name="multarget"></a><h5>Using Multiple Criteria to Specify an Installation Target</h5>
<p>You can use multiple criteria to specify an installation target, but there are
limitations.</p><p>Only one of following criteria can be specified at a time. And,
the following criteria cannot be combined with other criteria:</p>
<ul><li><p><tt>&lt;target_device_iscsi_parameter_source></tt></p></li>
<li><p><tt>&lt;target_device_name></tt> &ndash; Using either <tt>c#t#d#</tt> or <tt>boot_disk</tt></p></li>
<li><p><tt>&lt;target_device_select_volume_name></tt></p></li>
<li><p><tt>&lt;target_device_select_id></tt></p></li>
<li><p><tt>&lt;target_device_select_device_path></tt></p></li></ul>
<p>The following criteria can be combined with each other. But, they are invalid
if used with any of the criteria from the previous list.</p>
<ul><li><p><tt>&lt;target_device_type></tt></p></li>
<li><p><tt>&lt;target_device_vendor></tt></p></li>
<li><p><tt>&lt;target_device_size></tt></p></li></ul>
<p>The following examples show how you could combine these criteria.</p><p>In the following example, an SCSI Hitachi disk with at least 70
GB will be selected for the installation.</p><pre>...
&lt;ai_target_device>
        &lt;target_device_type>
        SCSI
        &lt;/target_device_type>
        &lt;target_device_vendor>
        HITACHI
        &lt;/target_device_vendor>
        &lt;target_device_size>
        146800640
        &lt;/target_device_size>
&lt;/ai_target_device>
...</pre><p>In the following example, an IDE disk with at least 12 GB
will be selected for the installation.</p><pre>...
&lt;ai_target_device>
        &lt;target_device_type>
        ATA
        &lt;/target_device_type>
        &lt;target_device_size>
        25165824
        &lt;/target_device_size>
&lt;/ai_target_device>
...</pre>
<hr><p><b>Note - </b>If an invalid manifest is provided to the AI client, the automated installation
aborts when validating the manifest. Error messages indicating the cause of the failed
syntactic validation can be found in <tt>/tmp/install_log</tt> file on installation client.</p>
<hr>


<a name="ievtoc"></a><h5>Using a VTOC Slice as the Installation Target</h5>
<p>If a slice is not specified, the automated installer, by default, selects slice
0 on the client to install the OpenSolaris OS. If you would
like to install the OpenSolaris OS on a different slice, you can specify
the slice in the AI manifest in the <tt>&lt;ai_target_device></tt> tag.</p><p>This example instructs the installer to install the OpenSolaris OS on slice 4.</p><pre>...
&lt;ai_target_device>
     &lt;target_device_name>c0t0000002037CD9F72d0&lt;/target_device_name>
     &lt;target_device_install_slice_number>4&lt;/target_device_install_slice_number>
&lt;/ai_target_device>
...</pre>

<a name="modpart"></a><h5>Modifying the Partitions and Slices on the Install Client</h5>
<p>You can modify the existing partitions and slices in the installation target. See
the following options:</p>
<ul><li><p><a href="#extpart">Creating an Extended Partition</a></p></li>
<li><p><a href="#iepartition">Deleting an <tt>fdisk</tt> Partition (x86 only)</a></p></li>
<li><p><a href="#createpart">Creating an <tt>fdisk</tt> Partition (x86 only)</a></p></li>
<li><p><a href="#ieslices">Deleting a VTOC Slice</a></p></li>
<li><p><a href="#createvtoc">Creating a VTOC Slice</a></p></li>
<li><p><a href="#iepreserve">Preserving VTOC Slices</a></p></li></ul>


<a name="extpart"></a><h5>Creating an Extended Partition</h5>
<p><b>Starting with the OpenSolaris 2010.03 release</b>, you can create an extended partition in an fdisk partition table
as part of your automated installation. An extended partition provides space for one of
more logical partitions. Multiple logical partitions can be created in an extended partition.</p><p>You can create an extended partition, or create logical partitions in a new
or existing extended partition, by using the <tt>&lt;ai_device_partitioning></tt> tag in the AI
manifest. See the following examples.</p><p><b>Create an extended partition</b> by using the <tt>&lt;ai_device_partitioning></tt> tag as in the following example:</p><pre>...
&lt;ai_device_partitioning>
     &lt;partition_action>create&lt;/partition_action>
     &lt;partition_size>max_size&lt;/partition_size>
     &lt;partition_type>EXTDOS&lt;/partition_type>
&lt;/ai_device_partitioning>
...</pre><p>In the example above, you are creating an extended partition. When applied to
extended or primary partitions, the <tt>max_size</tt> value uses the largest region of free
space on the disk to create the extended or primary partition. In the
new extended partition, a logical partition is automatically created that uses all the
space in the extended partition.</p><p>In this example, the partition type is set to EXTDOS. Other valid
text values for the <tt>partition_type</tt> tag include the SOLARIS, DOS16, FAT32, and DOSEXT.</p><p><b>Create a logical partition</b> inside an existing extended partition by using the same <tt>&lt;ai_device_partitioning></tt> tag as
in the following example:</p><pre>...
&lt;ai_device_partitioning>
     &lt;partition_action>create&lt;/partition_action>
     &lt;partition_size>max_size&lt;/partition_size>
     &lt;partition_type>SOLARIS&lt;/partition_type>
     &lt;partition_is_logical>true&lt;/partition_is_logical>
&lt;/ai_device_partitioning>
...</pre><p>In the example above, you are creating a new logical partition, of
the type SOLARIS, within the existing extended partition, using any available free space in
the extended partition.</p><p>The <tt>max_size</tt> value, as in the above example, specifies that the largest block
of free space in the extended partition will be used for the logical
partition.</p>
<hr><p><b>Note - </b>If there are no other logical partitions, the entire extended partition is used
for the logical partition.</p><p>If there is more than one logical partition, the total space for all
logical partitions in an extended partition cannot exceed the total space in the
extended partition.</p><p>If there is no available space for the logical partition because another logical
partition is already using all the space, this installation would fail.</p>
<hr>
<p><b>Create an extended partition that contains two new logical partitions</b> as shown in the following example.</p><pre>&lt;!-- create an extended partition in the largest block of free space -->
&lt;ai_device_partitioning>
&lt;partition_action>create&lt;/partition_action>
&lt;partition_size>max_size&lt;/partition_size>
&lt;partition_type>EXTDOS&lt;/partition_type>
&lt;/ai_device_partitioning>
&lt;!-- create a 10G FAT32 logical partition on the extended partition you just created-->
&lt;!-- in this example, the partition would consume the 
1st 10G of the extended partition -->
&lt;ai_device_partitioning>
&lt;partition_action>create&lt;/partition_action>
&lt;partition_is_logical>true&lt;/partition_is_logical>
&lt;partition_size>10&lt;/partition_size>
&lt;partition_size_units>G&lt;/partition_size_units>
&lt;partition_type>FAT32&lt;/partition_type>
&lt;/ai_device_partitioning>
&lt;!-- create a Solaris logical partition using the largest unused free space 
in the extended partition -->
&lt;!-- in this example, the partition would use the remaining space in the 
extended partition -->
&lt;ai_device_partitioning>
&lt;partition_action>create&lt;/partition_action>
&lt;partition_is_logical>true&lt;/partition_is_logical>
&lt;partition_type>SOLARIS&lt;/partition_type>
&lt;partition_size>max_size&lt;/partition_size>
&lt;/ai_device_partitioning></pre><p>This example accomplishes the following:</p>
<ul><li><p>Creates an extended partition using the largest region of free space available on the disk.</p></li>
<li><p>Creates a FAT32 logical partition in the extended partition, using the first contiguous 10GB of the available space.</p></li>
<li><p>Creates a Solaris logical partition using the largest remaining unused space.</p></li></ul>

<hr><p><b>Note - </b>On a fragmented disk, you can create multiple logical partitions, specifying <tt>max_size</tt>, until
all space has been used.</p>
<hr>


<a name="iepartition"></a><h5>Deleting an <tt>fdisk</tt> Partition (x86 only)</h5>

<hr><p><b>Note - </b>Partition operations are meaningful only for x86 clients.</p>
<hr>
<p>You can delete existing partitions during client installation. Use the tag, <tt>&lt;ai_device_partitioning></tt>, and
specify the <tt>delete</tt> action in the tag to delete a partition during
installation.</p><pre>...
&lt;ai_device_partitioning>
      &lt;partition_action>delete&lt;/partition_action>
      &lt;partition_number>3&lt;/partition_number>
&lt;/ai_device_partitioning>
...</pre>

<a name="createpart"></a><h5>Creating an <tt>fdisk</tt> Partition (x86 only)</h5>

<hr><p><b>Note - </b>Partition operations are meaningful only for x86 clients.</p>
<hr>
<p>You can create a new partition during client installation. Use the tag,
<tt>&lt;ai_device_partitioning></tt>, and specify the <tt>create</tt> action in the tag to create a
partition during installation.</p><p>The following example creates a Solaris partition. This example uses Gigabytes (GB) as
the unit for partition size. You could use megabytes (MB), terabytes (TB), or
sectors to define a partition. </p><pre>...
&lt;ai_device_partitioning>
      &lt;partition_action>create&lt;/partition_action>
      &lt;partition_type>SOLARIS&lt;/partition_type>
      &lt;partition_size>30&lt;/partition_size>
      &lt;partition_size_units>GB&lt;/partition_size_units>
&lt;/ai_device_partitioning>
...</pre>

<a name="ieslices"></a><h5>Deleting a VTOC Slice</h5>
<p>You can delete an existing VTOC slice during client installation. Use the tag,
<tt>&lt;ai_device_vtoc_slices></tt>, and specify the <tt>delete</tt> action in the tag to delete a
slice during installation.</p>
<hr><p><b>Note - </b>The size element is required, but only for XML validation.</p>
<hr>
<pre>...
&lt;ai_device_vtoc_slices>
       &lt;slice_action>delete&lt;/slice_action>
       &lt;slice_number>0&lt;/slice_number>
       &lt;slice_size>20&lt;/slice_size>
&lt;/ai_device_vtoc_slices>
...</pre>

<a name="createvtoc"></a><h5>Creating a VTOC Slice</h5>
<p>You can create a new VTOC slice during client installation. Use the tag,
<tt>&lt;ai_device_vtoc_slices></tt>, and specify the <tt>create</tt> action in the tag to create a
slice during installation. The following example shows how to create a new slice
5.</p><p>This example uses GB (Gigabytes) as the unit for slice size.</p><pre>...
&lt;ai_device_vtoc_slices>
       &lt;slice_action>create&lt;/slice_action>
       &lt;slice_number>5&lt;/slice_number>
       &lt;slice_size>20&lt;/slice_size>
       &lt;slice_size_units>GB&lt;/slice_size_units>
&lt;/ai_device_vtoc_slices>
...</pre>

<a name="iepreserve"></a><h5>Preserving VTOC Slices</h5>
<p>You can preserve an existing VTOC slice during client installation. Use the tag,
<tt>&lt;ai_device_vtoc_slices></tt>, and specify the &ldquo;preserve&rdquo; action in the tag to preserve an existing
slice during installation. The following example shows how to preserve VTOC slice 7.</p><pre>...
&lt;ai_device_vtoc_slices>
       &lt;slice_action>preserve&lt;/slice_action>
       &lt;slice_number>7&lt;/slice_number>
&lt;/ai_device_vtoc_slices>
...</pre>

<a name="iereboot"></a><h5>Specifying an Automatic Reboot After Installation</h5>
<p>By default, the automated installer does not reboot the client after a successful
installation of an OpenSolaris OS. However, if you want the client to automatically
reboot after a successful installation of the OpenSolaris OS, add the XML tag,
<tt>&lt;ai_auto_reboot></tt>, in the AI manifest, and set the reboot value in that tag
to <tt>true</tt>, as per the following snippet:</p><pre>...
&lt;ai_auto_reboot>
     true
&lt;/ai_auto_reboot>
...</pre>

<a name="repo"></a><h5>Specifying an IPS Repository</h5>
<p>The automated installer client must install packages from an IPS repository. You can
specify an IPS repository, a repository mirror, an a HTTP proxy for a
repository, or an additional repository as follows.</p><p>The IPS repository is defined in the AI manifest by using the
tag <tt>&lt;ai_pkg_repo_default_publisher></tt>. See the following example. This example specifies the repository located at
<a href="http://pkg.opensolaris.org">http://pkg.opensolaris.org</a>. The name of this repository is <tt>opensolaris.org</tt>.</p><pre>...
&lt;ai_manifest name=&quot;ai_manifest1&quot;>
      &lt;ai_pkg_repo_default_publisher>
          &lt;main url=&quot;http://pkg.opensolaris.org&quot; publisher=&quot;opensolaris.org&quot;/>
      &lt;/ai_pkg_repo_default_publisher>
&lt;/ai_manifest>
...</pre>

<a name="mirror"></a><h5>Specifying an IPS Repository Mirror</h5>
<p>You can add a mirror to an IPS repository in the AI
manifest as in this example:</p><pre>...
&lt;ai_manifest name=&quot;ai_manifest1&quot;>
      &lt;ai_pkg_repo_default_publisher>
          &lt;main url=&quot;http://pkg.opensolaris.org&quot; publisher=&quot;opensolaris.org&quot;/>
          &lt;mirror url="http://mymirror.test">
      &lt;/ai_pkg_repo_default_publisher>
&lt;/ai_manifest>
...</pre>

<a name="ieproxy"></a><h5>Specifying an HTTP Proxy to Reach an IPS Repository</h5>
<p>The client needs to reach the IPS repository defined in the AI
manifest to install the OpenSolaris OS. In a normal configuration, the DHCP server sends
DNS information to the client. This information is used to resolve the IPS
repository name to an IP address. In cases where DNS is not
set up, an HTTP proxy can be used to resolve the IPS repository
name and complete the client installation. The XML tag, <tt>&lt;ai_http_proxy></tt>, and value in the
manifest can contain the URL of the proxy as follows:</p><pre>...
&lt;ai_manifest name=&quot;http_proxy&quot;>
     &lt;ai_pkg_repo_default_publisher>
         &lt;main url=&quot;http://pkg.opensolaris.org&quot; publisher=&quot;opensolaris.org&quot;/>
     &lt;/ai_pkg_repo_default_publisher>
     &lt;ai_http_proxy url="http://129.101.77.121:8080"/>
&lt;/ai_manifest>
...</pre>

<a name="iemorerepo"></a><h5>Specifying an Additional Repository</h5>
<p>You can install custom packages from an IPS repository other than the repository
that was used for installation by specifying additional IPS repositories in the AI
manifest. Use the tag, <tt>&lt;ai_pkg_repo_addl_publisher></tt>, to add additional repositories to the AI
manifest.</p><pre>...
&lt;ai_manifest name=&quot;example1&quot;>
    &lt;ai_pkg_repo_default_publisher>
        &lt;main url=&quot;http://pkg.opensolaris.org&quot; publisher=&quot;opensolaris.org&quot;/>
    &lt;/ai_pkg_repo_default_publisher>
    &lt;ai_pkg_repo_addl_publisher>
        &lt;main url=&quot;http://pkg.mydomain&quot; publisher=&quot;mydomain&quot;/>
    &lt;/ai_pkg_repo_addl_publisher>
&lt;/ai_manifest>
...</pre>
<hr><p><b>Note - </b>Sometimes a package might be included in more than one repository. IPS searches
for that package in the repositories according to the order of the repository
in the manifest. When a package match that includes version number is found,
then IPS stops the search and installs that package.</p>
<hr>


<a name="iepkg"></a><h5>Specifying Packages to be Installed</h5>
<p>The following packages are needed for a successful installation of the OpenSolaris OS
and are included in the AI default manifest:</p>
<ul><li><p><tt>entire</tt></p></li>
<li><p><tt>SUNWcsd</tt></p></li>
<li><p><tt>SUNWcs</tt></p></li>
<li><p><tt>babel_install</tt></p></li></ul>
<p>In the <tt>&lt;ai_install_packages></tt> tag, you can additional packages to be added during installation.
However, you need to retain the default packages along with the additional packages.</p>
<hr><p><b>Note - </b>Due to dependency issues, <tt>entire</tt> must be listed first in the package list,
followed by <tt>SUNWcsd</tt>, and then <tt>SUNWcs</tt>. Any additional packages must be listed
after <tt>SUNWcs</tt>.</p>
<hr>
<p>In the following example, the <tt>openoffice</tt> and the <tt>SUNWTcl</tt> packages are added
as part of the OpenSolaris installation.</p><pre>&lt;ai_manifest name=&quot;ai_packages&quot;>
     &lt;ai_install_packages>
         &lt;pkg name="entire"/>
         &lt;pkg name="SUNWcsd"/>
         &lt;pkg name="SUNWcs"/>
         &lt;pkg name="babel_install"/>
         &lt;pkg name="openoffice"/>
         &lt;pkg name="SUNWTcl"/>
     &lt;/ai_install_packages>
     &lt;ai_uninstall_packages>
         &lt;pkg name="babel_install"/>
         &lt;pkg name="slim_install"/>
     &lt;/ai_uninstall_packages>
&lt;/ai_manifest></pre>
<hr><p><b>Note - </b>The default manifest first installs the <tt>babel_install</tt> package, then uninstalls it. 
<tt>babel_install</tt> is a cluster consisting of set of packages. When the <tt>babel_install</tt> cluster is
installed, all the packages in the cluster are installed. However, you cannot uninstall
packages that belong to a cluster. By uninstalling the cluster definition, the individual
packages can be deleted later. <tt>babel_install</tt> is used for convenience to install
all the required packages, but the cluster definition is not needed once installation
of packages is completed. The default manifest removes the cluster definition, so that
further customization of the packages can be done.</p><p><tt>slim_install</tt> is another cluster. And, <tt>slim_install</tt> is part of <tt>babel_install</tt> which is installed
by the default manifest. The default manifest then uninstalls <tt>slim_install</tt>, in order
to permit customization.</p>
<hr>


<a name="version"></a><h5>Specifying Packages to Install a Specific Version of OpenSolaris</h5>
<p>If the packages are specified as package names in the manifest without a
version noted, the automated installer installs the latest version of the packages. If
you want to install a specific version of the OpenSolaris OS, you can
specify the version in the package <tt>entire</tt>, by using the following form:</p><pre>&lt;pkg_name="entire@0.5.11-0.build#/></pre><p>The IPS repositories include the full FMRI for each version of a
package. Use the FMRI string to specify a specific version of the package,
<tt>entire</tt>, in the AI manifest.</p><p> The following example specifies that OpenSolaris build 111 be installed to the
client.</p><pre>&lt;ai_manifest name=&quot;ai_packages&quot;>
     &lt;ai_install_packages>
         &lt;pkg name="entire@0.5.11-0.111"/>
         &lt;pkg name="SUNWcsd"/>
         &lt;pkg name="SUNWcs"/>
         &lt;pkg name="babel_install"/>
         &lt;pkg name="openoffice"/>
         &lt;pkg name="SUNWTcl"/>
     &lt;/ai_install_packages>
     &lt;ai_uninstall_packages>
         &lt;pkg name="babel_install"/>
         &lt;pkg name="slim_install"/>
     &lt;/ai_uninstall_packages>
&lt;/ai_manifest></pre>
<hr><p><b>Note - </b>The build number or release of the AI ISO image that you
specify in the <tt>installadm create-service</tt> command must be the same build number or release of
the OpenSolaris operating system that you specify in the AI manifest.</p>
<hr>


<a name="allfields"></a><h4>Example: A Complete AI Manifest</h4>
<p>The following example shows a complete AI manifest where all the primary tags
are in use.</p><pre>&lt;ai_manifest name=&quot;ai_manifest1&quot;>
     &lt;ai_target_device>
         &lt;target_device_name>c0t0d0&lt;/target_device_name>
     &lt;/ai_target_device>                &lt;!-- delete partition 3 -->
     &lt;ai_device_partitioning>
         &lt;partition_action>delete&lt;/partition_action>
         &lt;partition_number>3&lt;/partition_number>
     &lt;/ai_device_partitioning>
     &lt;ai_device_partitioning>               &lt;!-- Create solaris partition -->
         &lt;partition_action>create&lt;/partition_action>
         &lt;partition_size>30&lt;/partition_size>
         &lt;partition_size_units>GB&lt;/partition_size_units>
         &lt;partition_type>SOLARIS&lt;/partition_type>
     &lt;/ai_device_partitioning>
     &lt;ai_device_vtoc_slices>                &lt;!-- Create VTOC slice 4 -->
         &lt;slice_action>create&lt;/slice_action>
         &lt;slice_number>0&lt;/slice_number>
         &lt;slice_size>30&lt;/slice_size>
         &lt;slice_size_units>GB&lt;/slice_size_units>
     &lt;/ai_device_vtoc_slices>
     &lt;ai_pkg_repo_default_publisher>               &lt;!-- IPS repository -->
         &lt;main url=&quot;http://pkg.opensolaris.org&quot; publisher=&quot;opensolaris.org&quot;/>
     &lt;/ai_pkg_repo_default_publisher>
     &lt;ai_http_proxy url="http://129.101.77.121:8080"/>       &lt;!-- Use http proxy to install pkgs from IPS -->
     &lt;ai_auto_reboot>true&lt;/ai_auto_reboot>            &lt;!-- Automatic reboot after successful installation -->
     &lt;ai_install_packages>
         &lt;pkg name="entire"/>
         &lt;pkg name="SUNWcsd"/>
         &lt;pkg name="SUNWcs"/>
         &lt;pkg name="babel_install"/>
         &lt;pkg name="SUNWTcl"/>
     &lt;/ai_install_packages>  &lt;!-- Due to dependency issues, entire must be listed first
            in the package list, followed by SUNWcsd, and then SUNWcs.
            Any additional packages must be listed after SUNWcs.  -->
     &lt;ai_uninstall_packages>
         &lt;pkg name="babel_install"/>
         &lt;pkg name="slim_install"/>
     &lt;/ai_uninstall_packages>
&lt;/ai_manifest></pre>
         </div>
      </td>
   </tr>

   <tr class="PageControls" valign="top">
      <td></td>
      <td>
         <table width="100%">
      	   <tr>
      	     <td>
                 <a href="manifest1.html">Previous</a>
             </td>
             <td align="right">
                 <a href="customsc.html">Next</a>
             </td>
           </tr>
         </table>
      </td>
   </tr>
</tbody>
</table>


</body>
</html>

